"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _context = _interopRequireDefault(require("./context"));

var _attachments = require("../attachments");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class NewAttachmentsContext extends _context.default {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   */
  constructor(vk, {
    type,
    object: update
  }) {
    super(vk);
    this.payload = update;
    let subType;
    let attachment; // eslint-disable-next-line default-case

    switch (type) {
      case 'photo_new':
        {
          subType = 'new_photo_attachment';
          attachment = new _attachments.PhotoAttachment(update, vk);
          break;
        }

      case 'video_new':
        {
          subType = 'new_video_attachment';
          attachment = new _attachments.VideoAttachment(update, vk);
          break;
        }

      case 'audio_new':
        {
          subType = 'new_audio_attachment';
          attachment = new _attachments.AudioAttachment(update, vk);
          break;
        }
    }

    this.attachments = [attachment];
    this.type = 'new_attachment';
    this.subTypes = [subType];
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }
  /**
   * Checks is attachment photo
   *
   * @return {boolean}
   */


  isPhoto() {
    return this.subTypes.includes('new_photo');
  }
  /**
   * Checks is attachment video
   *
   * @return {boolean}
   */


  isVideo() {
    return this.subTypes.includes('new_video');
  }
  /**
   * Checks is attachment audio
   *
   * @return {boolean}
   */


  isAudio() {
    return this.subTypes.includes('new_audio');
  }
  /**
   * Removes the attachment
   *
   * @return {Promise}
   */


  deleteAttachment() {
    if (this.isPhoto()) {
      const [photo] = this.getAttachments('photo');
      return this.vk.api.photos.delete({
        owner_id: photo.getOwnerId(),
        photo_id: photo.getId()
      });
    }

    if (this.isVideo()) {
      const [video] = this.getAttachments('video');
      return this.vk.api.video.delete({
        owner_id: video.getOwnerId(),
        video_id: video.getId()
      });
    }

    if (this.isAudio()) {
      const [audio] = this.getAttachments('audio');
      return this.vk.api.audio.delete({
        owner_id: audio.getOwnerId(),
        audio_id: audio.getId()
      });
    }

    return Promise.reject(new Error('Unsupported event for deleting attachment'));
  }

}

exports.default = NewAttachmentsContext;