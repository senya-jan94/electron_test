"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug = _interopRequireDefault(require("debug"));

var _cheerio = require("cheerio");

var _url = require("url");

var _errors = require("../errors");

var _fetchCookie = require("../util/fetch-cookie");

var _constants = require("../util/constants");

var _helpers = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug.default)('vk-io:auth:direct');
const {
  PAGE_BLOCKED,
  INVALID_PHONE_NUMBER,
  AUTHORIZATION_FAILED,
  FAILED_PASSED_CAPTCHA,
  MISSING_CAPTCHA_HANDLER,
  FAILED_PASSED_TWO_FACTOR,
  MISSING_TWO_FACTOR_HANDLER
} = _errors.authErrors;
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */

const CAPTCHA_ATTEMPTS = 3;
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE = 'act=security';

class DirectAuth {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, {
    app = vk.options.app,
    key = vk.options.key,
    agent = vk.options.agent,
    scope = vk.options.scope,
    login = vk.options.login,
    phone = vk.options.phone,
    password = vk.options.password
  } = {}) {
    this.vk = vk;
    this.app = app;
    this.key = key;
    this.agent = agent;
    this.scope = scope;
    this.login = login;
    this.phone = phone;
    this.password = password;
    this.started = false;
    this.captcha = null;
    this.twoFactor = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'DirectAuth';
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, Object.assign({}, options, {
      agent,
      compress: false,
      headers: Object.assign({}, headers, {
        'User-Agent': _constants.DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Returns permission page
   *
   * @param {Object} query
   *
   * @return {Response}
   */


  getPermissionsPage(query = {}) {
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = (0, _helpers.getAllUsersPermissions)();
    } else if (typeof scope !== 'number') {
      scope = (0, _helpers.getUsersPermissionsByName)(scope);
    }

    debug('auth scope %s', scope);
    const {
      app,
      key,
      login,
      phone,
      password
    } = this;
    const params = new _url.URLSearchParams(Object.assign({}, query, {
      username: login || phone,
      grant_type: 'password',
      client_secret: key,
      '2fa_supported': this.vk.twoFactorHandler !== null ? 1 : 0,
      v: _constants.API_VERSION,
      client_id: app,
      password,
      scope
    }));
    const url = new _url.URL(`https://oauth.vk.com/token?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run() {
    if (this.started) {
      throw new _errors.AuthError({
        message: 'Authorization already started!',
        code: AUTHORIZATION_FAILED
      });
    }

    this.started = true;
    this.fetchCookie = (0, _fetchCookie.fetchCookieFollowRedirectsDecorator)();
    let response = await this.getPermissionsPage();
    let text;
    const isProcessed = true;

    while (isProcessed) {
      text = await response.text();
      let isJSON = true;

      try {
        text = JSON.parse(text);
      } catch (e) {
        isJSON = false;
      }

      if (isJSON && 'access_token' in text) {
        const {
          email = null,
          user_id: user = null,
          expires_in: expires = null,
          access_token: token
        } = text;
        return {
          email,
          user: user !== null ? Number(user) : null,
          token,
          expires: expires !== null ? Number(expires) : null
        };
      } else if (isJSON && 'error' in text) {
        if (text.error === 'need_captcha') {
          response = await this.processCaptcha(text);
          continue;
        }

        if (text.error === 'need_validation') {
          if ('validation_type' in text) {
            response = await this.processTwoFactor(text);
            continue;
          }

          const $ = (0, _cheerio.load)(text);
          response = this.processSecurityForm(response, $);
          continue;
        }

        throw new _errors.AuthError({
          message: 'Unsupported type validation',
          code: AUTHORIZATION_FAILED
        });
      }

      throw new _errors.AuthError({
        message: 'Authorization failed',
        code: AUTHORIZATION_FAILED
      });
    }
  }
  /**
   * Process captcha
   *
   * @param {Object} payload
   *
   * @return {Response}
   */


  async processCaptcha({
    captcha_sid: sid,
    captcha_img: src
  }) {
    debug('captcha process');

    if (this.captcha !== null) {
      this.captcha.reject(new _errors.AuthError({
        message: 'Incorrect captcha code',
        code: FAILED_PASSED_CAPTCHA
      }));
      this.captcha = null;
      this.captchaAttempts += 1;
    }

    if (this.vk.captchaHandler === null) {
      throw new _errors.AuthError({
        message: 'Missing captcha handler',
        code: MISSING_CAPTCHA_HANDLER
      });
    }

    if (this.captchaAttempts >= CAPTCHA_ATTEMPTS) {
      throw new _errors.AuthError({
        message: 'Maximum attempts passage captcha',
        code: FAILED_PASSED_CAPTCHA
      });
    }

    const payload = {
      type: _constants.captchaTypes.DIRECT_AUTH,
      sid,
      src
    };
    const key = await new Promise((resolveCaptcha, rejectCaptcha) => {
      this.vk.captchaHandler(payload, code => new Promise((resolve, reject) => {
        if (code instanceof Error) {
          rejectCaptcha(code);
          reject(code);
          return;
        }

        this.captcha = {
          resolve,
          reject
        };
        resolveCaptcha(code);
      }));
    });
    return await this.getPermissionsPage({
      captcha_sid: sid,
      captcha_key: key
    });
  }
  /**
   * Process two-factor
   *
   * @param {Object} response
   *
   * @return {Promise<Response>}
   */


  async processTwoFactor({
    validation_type: validationType,
    phone_mask: phoneMask
  }) {
    debug('process two-factor handle');

    if (this.twoFactor !== null) {
      this.twoFactor.reject(new _errors.AuthError({
        message: 'Incorrect two-factor code',
        code: FAILED_PASSED_TWO_FACTOR
      }));
      this.twoFactor = null;
      this.twoFactorAttempts += 1;
    }

    if (this.vk.twoFactorHandler === null) {
      throw new _errors.AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER
      });
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS) {
      throw new _errors.AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR
      });
    }

    const type = validationType === '2fa_app' ? 'app' : 'sms';
    const key = await new Promise(resolveTwoFactor => {
      this.vk.twoFactorHandler({
        type,
        phoneMask
      }, code => new Promise((resolve, reject) => {
        this.twoFactor = {
          resolve,
          reject
        };
        resolveTwoFactor(code);
      }));
    });
    return await this.getPermissionsPage({
      code: key
    });
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new _errors.AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = (0, _helpers.parseFormField)($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = (0, _helpers.getFullURL)(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new _url.URLSearchParams(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE)) {
      throw new _errors.AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER
      });
    }

    return response;
  }

}

exports.default = DirectAuth;