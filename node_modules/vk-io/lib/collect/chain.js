"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("util");

var _request = _interopRequireDefault(require("../api/request"));

var _helpers = require("../util/helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Chain {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.queue = [];
    this.started = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Chain';
  }
  /**
   * Adds method to queue
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<mixed>}
   */


  append(method, params) {
    if (this.started) {
      throw new Error('Chain already started');
    }

    const request = new _request.default(method, params);
    this.queue.push(request);
    return request.promise;
  }
  /**
   * Promise based
   *
   * @param {Function} thenFn
   * @param {Function} catchFn
   *
   * @return {Promise<Object>}
   */


  then(thenFn, catchFn) {
    return Promise.resolve(this.run()).then(thenFn, catchFn);
  }
  /**
   * Starts the chain
   *
   * @return {Promise}
   */


  async run() {
    if (this.started) {
      throw new Error('Chain already started');
    }

    this.started = true;
    const {
      queue
    } = this;

    if (queue.length === 0) {
      return [];
    }

    let out = {
      response: [],
      errors: []
    };

    while (queue.length > 0) {
      const tasks = queue.splice(0, 25);
      const code = (0, _helpers.getChainReturn)(tasks.map(String));

      try {
        const response = await this.vk.api.execute({
          code
        });
        (0, _helpers.resolveExecuteTask)(tasks, response);
        out = {
          response: [...out.response, ...response.response],
          errors: [...out.errors, ...response.errors]
        };
      } catch (error) {
        for (const task of tasks) {
          task.reject(error);
        }

        throw error;
      }
    }

    return out;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [_util.inspect.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      queue
    } = this;
    const payload = {
      started,
      queue
    };
    return `${options.stylize(name, 'special')} ${(0, _util.inspect)(payload, options)}`;
  }

}

exports.default = Chain;